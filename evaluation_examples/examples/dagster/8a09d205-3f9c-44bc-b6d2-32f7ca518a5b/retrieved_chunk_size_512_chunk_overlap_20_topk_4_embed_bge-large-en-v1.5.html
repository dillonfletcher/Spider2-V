Documentation Source:
release-1-7-2.dagster.dagster-docs.io/integrations/dbt/using-dbt-with-dagster/upstream-assets.html

Documentation Title:
Using Dagster with dbt, part 3: Define assets upstream of your dbt models

Documentation Content:
You'll write Python code that populates this table by fetching data from the web. This will allow you to launch runs that first execute Python code to populate the <code>raw_customers</code>table and then invoke dbt to populate the downstream tables.</p><p>You'll:</p><ul><a>Install the Pandas and DuckDB Python libraries</a><a>Define an upstream Dagster asset</a><a>In the dbt project, replace a seed with a source</a><a>Materialize the assets using the Dagster UI</a></ul><h2>Step 1: Install the Pandas and DuckDB Python libraries<span>#</span></h2><p>The Dagster asset that you write will fetch data using <a>Pandas</a>and write it out to your DuckDB warehouse using <a>DuckDB's Python API</a>. To use these, you'll need to install them:</p><code>pip <span>install</span>pandas duckdb pyarrow
</code><h2>Step 2: Define an upstream Dagster asset<span>#</span></h2><p>To fetch the data the dbt models require, we'll write a Dagster asset for <code>raw_customers</code>. We'll put this asset in our <code>assets.py</code>file, inside the <code>jaffle_dagster</code>directory. This is the file that contains the code that defines our dbt models, which we reviewed at the end of the <a>last section</a>.



Documentation Source:
release-1-7-2.dagster.dagster-docs.io/integrations/dbt/using-dbt-with-dagster/load-dbt-models.html

Documentation Title:
Using Dagster with dbt, part 2: Load dbt models as Dagster assets

Documentation Content:
</span><p>At this point, you should have a <a>fully-configured dbt project</a>that's ready to work with Dagster.</p><p>In this section, you'll finally begin integrating dbt with Dagster! To do this, you'll:</p><ul><a>Create a Dagster project that wraps your dbt project</a><a>Inspect your Dagster project in Dagster's UI</a><a>Build your dbt models in Dagster</a><a>Understand the Python code in your Dagster project</a></ul><h2>Step 1: Create a Dagster project that wraps your dbt project<span>#</span></h2><p>You can create a Dagster project that wraps your dbt project by using the <code>dagster-dbt</code>command line interface. Make sure you're in the directory where your <code>dbt_project.yml</code>is. If you're continuing from the previous section, then you'll already be in this directory. Then, run:</p><code>dagster-dbt project scaffold --project-name jaffle_dagster
</code><p>This creates a directory called <code>jaffle_dagster/</code>inside the current directory. The <code>jaffle_dagster/</code>directory contains a set of files that define a Dagster project.</p><p>In general, it's up to you where to put your Dagster project. It's most common to put your Dagster project at the root of your git repository. Therefore, in this case, because the <code>dbt_project.yml</code>was at the root of the <code>jaffle_shop</code>git repository, we created our Dagster project there.</p><p><strong>Note</strong>: The <code>dagster-dbt project scaffold</code>command creates the Dagster project in whatever directory you run it from.



Documentation Source:
release-1-7-2.dagster.dagster-docs.io/integrations/dbt/using-dbt-with-dagster/upstream-assets.html

Documentation Title:
Using Dagster with dbt, part 3: Define assets upstream of your dbt models

Documentation Content:
The implementation inside the function fetches data from the internet and writes it to a table in our DuckDB database. Similar to how running a dbt model executes a select statement, materializing this asset will execute this Python code.</p></ol><p>Finally, let's update the <code>assets</code>argument of our <code>Definitions</code>object, in <code>definitions.py</code>, to include the new asset we just defined:</p><code><span>import</span>os

<span>from</span>dagster <span>import</span>Definitions
<span>from</span>dagster_dbt <span>import</span>DbtCliResource

<span>from</span><span>.</span>assets <span>import</span>jaffle_shop_dbt_assets<span>,</span>raw_customers
<span>from</span><span>.</span>constants <span>import</span>dbt_project_dir
<span>from</span><span>.</span>schedules <span>import</span>schedules

defs <span>=</span>Definitions<span>(</span>assets<span>=</span><span>[</span>raw_customers<span>,</span>jaffle_shop_dbt_assets<span>]</span><span>,</span>schedules<span>=</span>schedules<span>,</span>resources<span>=</span><span>{</span><span>"dbt"</span><span>:</span>DbtCliResource<span>(</span>project_dir<span>=</span>os<span>.</span>fspath<span>(</span>dbt_project_dir<span>)</span><span>)</span><span>,</span><span>}</span><span>,</span><span>)</span></code><h2>Step 3: In the dbt project, replace a seed with a source<span>#</span></h2><ol><li><p>Because we're replacing it with a Dagster asset, we no longer need the dbt seed for <code>raw_customers</code>, so we can delete it:</p><code><span>cd</span><span>.



Documentation Source:
release-1-7-2.dagster.dagster-docs.io/integrations/dbt/using-dbt-with-dagster/load-dbt-models.html

Documentation Title:
Using Dagster with dbt, part 2: Load dbt models as Dagster assets

Documentation Content:
Materializing an asset means running some computation to update its contents in persistent storage. In this tutorial, that persistent storage is our local DuckDB database.</p><p>To build your dbt project, i.e. materialize your assets, click the <strong>Materialize all</strong>button near the top right corner of the page. This will launch a run to materialize the assets. When finished, the <strong>Materialized</strong>and <strong>Latest Run</strong>attributes in the asset will be populated:</p><img/><p>After the run completes, you can:</p><ul><li>Click the <strong>asset</strong>to open a sidebar containing info about the asset, including its last materialization stats and a link to view the <a><strong>Asset details</strong>page</a></li><li>Click the ID of the <strong>Latest Run</strong>in an asset to view the <strong>Run details</strong>page. This page contains detailed info about the run, including timing information, errors, and logs.</li></ul><h2>Step 4: Understand the Python code in your Dagster project<span>#</span></h2><p>You saw how you can create a Dagster project that loads a dbt project. How does this work? Understanding how Dagster loads a dbt project will give you a foundation for customizing how Dagster runs your dbt project, as well as for connecting it to other data assets outside of dbt.</p><p>The most important file is the Python file that contains the set of definitions for Dagster to load: <code>jaffle_shop/definitions.py</code>. Dagster executes the code in this file to find out what assets it should be aware of, as well as details about those assets.



